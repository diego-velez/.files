#!/usr/bin/python

from datetime import datetime
import re
import subprocess
import sys
from typing import NamedTuple


class Alarm(NamedTuple):
    id: int
    date: datetime
    user: str


create_alarm_choice = "Create Alarm"
alarm_re = re.compile(r"^(\d+)\t(\w+ \w+  \d+ \d+:\d+:\d+ \d+) a (\w+)$")


def notify_user(title: str, body: str = ""):
    subprocess.run(["notify-send", "-t", "5000", title, body])


def get_menu_input(options: bytes = b"") -> str:
    choice = subprocess.run(
        ["fuzzel", "--dmenu", "--font=:size=16"],
        input=options,
        capture_output=True,
    )
    if choice.returncode != 0:
        raise RuntimeError(f"Error getting menu response!  `{choice.stderr}`")

    return choice.stdout.decode().strip()


def parse_alarm(alarm: str) -> Alarm:
    alarm_match = alarm_re.match(alarm)
    if alarm_match is None:
        notify_user(f"Alarm syntax does not match `{alarm}`!")
        raise RuntimeError("Alarm syntax does not match!!")

    id: int = int(alarm_match.group(1))
    date = datetime.strptime(alarm_match.group(2), "%a %b %d %H:%M:%S %Y")
    user = alarm_match.group(3)
    return Alarm(id, date, user)


def get_alarms() -> list[Alarm]:
    a = subprocess.run(["atq"], capture_output=True)
    if a.returncode != 0:
        print("Error fetching current alarms!", file=sys.stderr)
        raise RuntimeError(f"Error fetching current alarms!  {a.stderr}")
    alarms_output = a.stdout.decode().strip()

    # Return if there are no alarms
    if len(alarms_output) == 0:
        return list()

    alarms: list[Alarm] = list()
    for alarm in alarms_output.split("\n"):
        alarms.append(parse_alarm(alarm.strip()))

    return alarms


def create_alarm():
    # TODO: Implemente create alarm feature
    raise NotImplementedError("Implement create alarm feature")


def selected_alarm(alarm: Alarm):
    output = subprocess.run(["atrm", str(alarm.id)], capture_output=True)
    if output.returncode != 0:
        notify_user("Could not delete alarm!", output.stderr.decode())
        raise RuntimeError(f"Error deleting alarm {alarm.id}!!  {output.stderr}")
    notify_user(f"Successfully deleted alarm {alarm.id}!", output.stdout.decode())


def run_menu(alarms: list[Alarm]):
    options_builder: list[str] = list()
    for alarm in alarms:
        date_format = alarm.date.strftime("%d %b %Y at %H:%M")
        option = f"{alarm.id}\t{date_format}"
        options_builder.append(option)
    options_builder.append(create_alarm_choice)

    choice = get_menu_input("\n".join(options_builder).encode())
    if choice == create_alarm_choice:
        create_alarm()
        return

    choice_id = choice.split("\t")[0]
    alarm = None
    for a in alarms:
        if a.id == int(choice_id):
            alarm = a
            break
    if alarm is None:
        notify_user(f"Alarm {choice_id} does not exist!!")
        raise RuntimeError(f"Alarm {choice_id} does not exist!")

    selected_alarm(alarm)


if __name__ == "__main__":
    alarms = get_alarms()
    run_menu(alarms)
